<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- Composer
    using XML XPath Wrapper to compose new documents
    http://www.di.uminho.pt/~jcr/PROJS/Composer/
    Copyright (C) 2003 José Carlos Ramalho
    Permission to use granted under GPL or MPL.

    History: 
    2003-10-15 Created jcr
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias">
  <xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/>
  <!-- Category: top-level-element -->
  <xsl:output method="xml" omit-xml-declaration="no" standalone="yes" indent="yes"/>
  <xsl:template match="/">
    <xsl:comment>
      Generated by Composer.
      http://www.di.uminho.pt/~jcr/PROJS/Composer/
      Copyright (C) 2003 José Carlos Ramalho
      Permission to use granted under GPL or MPL.

      History: 
      2003-10-15 Created jcr    
      </xsl:comment>
    <axsl:stylesheet version="1.0">
      <axsl:output method="xml" omit-xml-declaration="no" encoding="iso-8859-1" standalone="yes" indent="yes"/>
      <axsl:template match="/">
        <xsl:element name="{new-doc/target}">
          <xsl:apply-templates select="new-doc/part"  mode="do-all-parts"/>
        </xsl:element>
      </axsl:template>
      <xsl:apply-templates/>
      <axsl:template match="text()" priority="-1">
        <!-- strip characters -->
      </axsl:template>
    </axsl:stylesheet>
  </xsl:template>
  
  <!-- Cálculo do corpo da stylesheet 
         geração de uma template para cada query -->
         
 <xsl:template match="query" mode="do-all-parts">
     <xsl:choose>
      <xsl:when test="container">
          <xsl:element name="{container}">
              <axsl:apply-templates mode="P{count(../../preceding-sibling::*)}Q{count(preceding-sibling::*)}" select="document('{../../source}')"/>
          </xsl:element>
      </xsl:when>
      <xsl:otherwise>
          <axsl:apply-templates mode="P{count(../../preceding-sibling::*)}Q{count(preceding-sibling::*)}" select="document('{../../source}')"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

  <xsl:template match="part" mode="do-all-parts">
    <xsl:choose>
      <xsl:when test="container">
          <axsl:element name="{container}">
              <xsl:apply-templates mode="do-all-parts" select="query-set"/>
          </axsl:element>
      </xsl:when>
      <xsl:otherwise>
           <xsl:apply-templates mode="do-all-parts" select="query-set"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template match="text()" mode="do-all-parts" priority="-1"/>
  
<!-- .............................................................................. 
       Now the tricky parts
       .............................................................................. -->
       
<xsl:template match="query">
		<axsl:template mode="P{count(../../preceding-sibling::*)}Q{count(preceding-sibling::*)}" match="{qexp}">
            <xsl:choose>
              <xsl:when test="container">
                  <xsl:element name="{container}">
                     <axsl:copy-of select="."/>
                  </xsl:element>
              </xsl:when>
              <xsl:otherwise>
                   <axsl:copy-of select="."/>
              </xsl:otherwise>
            </xsl:choose>
		</axsl:template>
		<axsl:template match="text()" priority="-1" mode="P{count(../../preceding-sibling::*)}Q{count(preceding-sibling::*)}">
			<!-- strip characters -->
		</axsl:template>
	</xsl:template>

  <xsl:template match="text()" priority="-1"/>

  
  </xsl:stylesheet>
